#### 15.6.2.3 Sorted Index Builds



`InnoDB` performs a bulk load instead of inserting one index record at a time when creating or rebuilding indexes. This method of index creation is also known as a sorted index build. Sorted index builds are not supported for spatial indexes.

> `InnoDB` 在创建或重建索引时执行批量加载，而不是一次插入一条索引记录。这种索引创建方法也称为排序索引构建。空间索引不支持排序索引构建。

There are three phases to an index build. In the first phase, the [clustered index](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index) is scanned, and index entries are generated and added to the sort buffer. When the [sort buffer](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sort_buffer) becomes full, entries are sorted and written out to a temporary intermediate file. This process is also known as a “run”. In the second phase, with one or more runs written to the temporary intermediate file, a merge sort is performed on all entries in the file. In the third and final phase, the sorted entries are inserted into the [B-tree](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree).

> 索引构建分为三个阶段。在第一阶段，扫描聚簇索引，生成索引条目并添加到排序缓冲区。当 [排序缓冲区](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sort_buffer) 变满时，条目将被排序并写入临时中间文件。此过程也称为“run”。在第二阶段，将一个或多个run写入临时中间文件，对文件中的所有条目执行合并排序。在第三阶段，将排序后的条目插入 [B-tree](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree)。

Prior to the introduction of sorted index builds, index entries were inserted into the B-tree one record at a time using insert APIs. This method involved opening a B-tree [cursor](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_cursor) to find the insert position and then inserting entries into a B-tree page using an [optimistic](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimistic) insert. If an insert failed due to a page being full, a [pessimistic](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_pessimistic) insert would be performed, which involves opening a B-tree cursor and splitting and merging B-tree nodes as necessary to find space for the entry. The drawbacks of this “top-down” method of building an index are the cost of searching for an insert position and the constant splitting and merging of B-tree nodes.

> 在引入排序索引构建之前，使用插入 API 将索引条目一次插入 B 树一条。此方法涉及创建 B 树 [cursor](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_cursor) 以找到插入位置，然后使用 [optimistic](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimistic) (乐观)将条目插入 B 树的页。如果由于页面已满而导致插入失败，则将执行 [pessimistic](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_pessimistic) (悲观)插入，其中涉及打开 B -tree cursor以及根据需要拆分和合并 B 树节点以找到条目空间。这种“自上而下”的构建索引方法的缺点是搜索插入位置的成本高以及 B 树节点的不断拆分和合并。

Sorted index builds use a “bottom-up” approach to building an index. With this approach, a reference to the right-most leaf page is held at all levels of the B-tree. The right-most leaf page at the necessary B-tree depth is allocated and entries are inserted according to their sorted order. Once a leaf page is full, a node pointer is appended to the parent page and a sibling leaf page is allocated for the next insert. This process continues until all entries are inserted, which may result in inserts up to the root level. When a sibling page is allocated, the reference to the previously pinned leaf page is released, and the newly allocated leaf page becomes the right-most leaf page and new default insert location.

>排序索引构建使用“自下而上”的方法来构建索引。使用这种方法，最右侧叶子page的引用保存在 B 树的所有层级(最右侧叶子节点会保存在父级节点上，作为边界)。位于B+Tree需要的深度的最右叶子页被分配，条目按它们排序后的顺序插入。一旦叶子页满了，一个节点指针追加到父页上，同层叶子页被分配用于接下来的插入。这个过程持续至所有条目插入完成，这可能导致插入一直到顶层。分配同级页时，释放对先前固定叶页的引用，新分配的叶页成为最右边的叶子页和新的默认插入位置。
>
>（*白话解读：最底层的最右叶子页插入索引记录，如果当前最右叶子页满了，生成一个新的最右叶子页作为接下来的插入位置，在新旧最右叶子页之间建立指针链接，然后把指向旧最右叶子页的指针追加到上一层的最右叶子页，触发上一层的最右叶子页插入，逻辑跟前面是一样的，这是个递归的过程，直至根页。这是一个***自底向上、递归构建的过程***。*）

##### Reserving B-tree Page Space for Future Index Growth

>为后续插入保留空间

To set aside space for future index growth, you can use the [`innodb_fill_factor`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor) variable to reserve a percentage of B-tree page space. For example, setting [`innodb_fill_factor`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor) to 80 reserves 20 percent of the space in B-tree pages during a sorted index build. This setting applies to both B-tree leaf and non-leaf pages. It does not apply to external pages used for [`TEXT`](https://dev.mysql.com/doc/refman/8.0/en/blob.html) or [`BLOB`](https://dev.mysql.com/doc/refman/8.0/en/blob.html) entries. The amount of space that is reserved may not be exactly as configured, as the [`innodb_fill_factor`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor) value is interpreted as a hint rather than a hard limit.

>要为未来的索引增长留出空间，可以使用 [`innodb_fill_factor`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor) 变量来保留百分比B树页面空间。例如，将 [`innodb_fill_factor`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor) 设置为 80， 在排序索引构建时会在 B-tree 页面中保留 20% 的空间。此设置适用于 B 树的叶子页面和非叶子页面。它不适用于 [`TEXT`](https://dev.mysql.com/doc/refman/8.0/en/blob.html) 或 [`BLOB`](https://dev. mysql.com/doc/refman/8.0/en/blob.html) 条目。保留的空间量可能与配置不完全相同，因为 [`innodb_fill_factor`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor) 值是被解释为提示而不是硬限制。

##### Sorted Index Builds and Full-Text Index Support

Sorted index builds are supported for [fulltext indexes](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_fulltext_index). Previously, SQL was used to insert entries into a fulltext index.

>全文索引支持排序索引构建

##### Sorted Index Builds and Compressed Tables

For [compressed tables](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_compression), the previous index creation method appended entries to both compressed and uncompressed pages. When the modification log (representing free space on the compressed page) became full, the compressed page would be recompressed. If compression failed due to a lack of space, the page would be split. With sorted index builds, entries are only appended to uncompressed pages. When an uncompressed page becomes full, it is compressed. Adaptive padding is used to ensure that compression succeeds in most cases, but if compression fails, the page is split and compression is attempted again. This process continues until compression is successful. For more information about compression of B-Tree pages, see [Section 15.9.1.5, “How Compression Works for InnoDB Tables”](https://dev.mysql.com/doc/refman/8.0/en/innodb-compression-internals.html).

>对于[压缩表](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_compression)，以前的索引创建方法将条目附加到压缩和未压缩的页面。当修改日志（表示压缩页面上的可用空间）变满时，将重新压缩压缩页面。如果由于空间不足而导致压缩失败，则页面将被拆分。使用排序索引构建，条目仅附加到未压缩的页面。当一个未压缩的页面变满时，它就会被压缩。自适应填充用于确保在大多数情况下压缩成功，但如果压缩失败，则会拆分页面并再次尝试压缩。这个过程一直持续到压缩成功

##### Sorted Index Builds and Redo Logging

[Redo logging](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_redo_log) is disabled during a sorted index build. Instead, there is a [checkpoint](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_checkpoint) to ensure that the index build can withstand an unexpected exit or failure. The checkpoint forces a write of all dirty pages to disk. During a sorted index build, the [page cleaner](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_cleaner) thread is signaled periodically to flush [dirty pages](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_dirty_page) to ensure that the checkpoint operation can be processed quickly. Normally, the page cleaner thread flushes dirty pages when the number of clean pages falls below a set threshold. For sorted index builds, dirty pages are flushed promptly to reduce checkpoint overhead and to parallelize I/O and CPU activity.

> [重做日志](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_redo_log) 在排序索引构建期间被禁用。相反， [检查点](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_checkpoint) 用来确保索引构建可以承受意外退出或失败。检查点强制将所有脏页写入磁盘。在排序索引构建期间，[页面清理器](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_cleaner）线程定期发出信号以刷新[脏页面]（https:// /dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_dirty_page) 用以确保可以快速处理检查点操作。通常，当干净页面的数量低于设置的阈值时，页面清理线程会刷新脏页面。对于排序索引构建，脏页被迅速刷新以减少检查点开销并并行化 I/O 和 CPU 活动。

##### Sorted Index Builds and Optimizer Statistics

Sorted index builds may result in [optimizer](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimizer) statistics that differ from those generated by the previous method of index creation. The difference in statistics, which is not expected to affect workload performance, is due to the different algorithm used to populate the index.

>排序索引构建可能会导致 [优化器](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimizer) 统计信息与以前的索引创建方法生成的统计信息不同。统计数据的差异，不会影响工作负载性能，是因为填充索引的算法不同造成的。



参考：https://coderbee.net/index.php/tag/sorted-index-build