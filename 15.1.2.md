### 15.1.2 Best Practices for InnoDB Tables

This section describes best practices when using `InnoDB` tables.

- Specify a primary key for every table using the most frequently queried column or columns, or an auto-increment value if there is no obvious primary key.

> 把每个表最常使用查询的一列或多列指定为一个主键，如果没有明显的主键，则指定一个自增主键。

- Use joins wherever data is pulled from multiple tables based on identical ID values from those tables. For fast join performance, define foreign keys on the join columns, and declare those columns with the same data type in each table. Adding foreign keys ensures that referenced columns are indexed, which can improve performance. Foreign keys also propagate deletes and updates to all affected tables, and prevent insertion of data in a child table if the corresponding IDs are not present in the parent table.

> 在根据多个表中的相同 ID 值从多个表中提取数据的地方使用join。为了快速的join性能，在连接列上定义外键，并在每个表中用相同的数据类型声明这些列。添加外键确保引用的列被索引，这可以提高性能。外键还会将删除和更新传播到所有受影响的表，并阻止在子表中插入在父表中不存在相应 ID的数据。

- Turn off autocommit. Committing hundreds of times a second puts a cap on performance (limited by the write speed of your storage device).

  > 关闭自动提交。每秒提交数百次会限制性能（受存储设备的写入速度限制）

- Group sets of related DML operations into transactions by bracketing them with `START TRANSACTION` and `COMMIT` statements. While you don't want to commit too often, you also don't want to issue huge batches of [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html), [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html), or [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html) statements that run for hours without committing.

> 通过用 START TRANSACTION 和 COMMIT 语句将相关的 DML 操作集分组到事务中。虽然您不想太频繁地提交，但您也不想发出大量运行数小时而不提交的 INSERT、UPDATE 或 DELETE 语句。

- Do not use [`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html) statements. `InnoDB` can handle multiple sessions all reading and writing to the same table at once without sacrificing reliability or high performance. To get exclusive write access to a set of rows, use the [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html) syntax to lock just the rows you intend to update.

> 不要使用 LOCK TABLES 语句。 InnoDB 可以处理多个会话，同时读取和写入同一个表，而不会牺牲可靠性或高性能。要获得对多行的独占写访问权限，请使用 SELECT ... FOR UPDATE 语法仅锁定要更新的行。

- Enable the [`innodb_file_per_table`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table) variable or use general tablespaces to put the data and indexes for tables into separate files instead of the system tablespace. The [`innodb_file_per_table`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table) variable is enabled by default.

> 启用 innodb_file_per_table 变量或使用通用表空间将表的数据和索引放入单独的文件而不是系统表空间。默认情况下启用 innodb_file_per_table 变量。

- Evaluate whether your data and access patterns benefit from the `InnoDB` table or page compression features. You can compress `InnoDB` tables without sacrificing read/write capability.

> 评估您的数据和访问模式是否受益于 InnoDB 表或页面压缩功能。您可以在不牺牲读/写能力的情况下压缩 InnoDB 表。

- Run the server with the [`--sql_mode=NO_ENGINE_SUBSTITUTION`](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sql_mode) option to prevent tables from being created with storage engines that you do not want to use.

> 使用 --sql_mode=NO_ENGINE_SUBSTITUTION 选项运行服务器，以防止使用您不想使用的存储引擎创建表。









