### 15.5.3 Adaptive Hash Index



The adaptive hash index enables `InnoDB` to perform more like an in-memory database on systems with appropriate combinations of workload and sufficient memory for the buffer pool without sacrificing transactional features or reliability. The adaptive hash index is enabled by the [`innodb_adaptive_hash_index`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index) variable, or turned off at server startup by `--skip-innodb-adaptive-hash-index`.

> 自适应哈希索引使`InnoDB`能够在具有适当的工作负载组合和足够的缓冲池内存的系统上更像内存数据库，而不会牺牲事务功能或可靠性。自适应哈希索引由 [`innodb_adaptive_hash_index`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index) 变量启用，或在服务器启动时通过`--skip-innodb-adaptive-hash-index` 关闭。

Based on the observed pattern of searches, a hash index is built using a prefix of the index key. The prefix can be any length, and it may be that only some values in the B-tree appear in the hash index. Hash indexes are built on demand for the pages of the index that are accessed often.

> Innodb根据观察到的查询请求，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只有B树中的一些值出现在哈希索引中。哈希索引是针对经常被访问的索引页面而构建的。

If a table fits almost entirely in main memory, a hash index speeds up queries by enabling direct lookup of any element, turning the index value into a sort of pointer. `InnoDB` has a mechanism that monitors index searches. If `InnoDB` notices that queries could benefit from building a hash index, it does so automatically.

> 如果一个表几乎完全适合主内存，哈希索引通过启用对任何元素的直接查找来加速查询，将索引值转换为一种指针(?)。 `InnoDB` 有一个监控索引搜索的机制。如果“InnoDB”注意到查询可以从构建哈希索引中受益，它会自动这样做。

With some workloads, the speedup from hash index lookups greatly outweighs the extra work to monitor index lookups and maintain the hash index structure. Access to the adaptive hash index can sometimes become a source of contention under heavy workloads, such as multiple concurrent joins. Queries with `LIKE` operators and `%` wildcards also tend not to benefit. For workloads that do not benefit from the adaptive hash index, turning it off reduces unnecessary performance overhead. Because it is difficult to predict in advance whether the adaptive hash index is appropriate for a particular system and workload, consider running benchmarks with it enabled and disabled.

>对于某些工作负载，哈希索引查找带来的加速大大超过了监控索引查找和维护哈希索引结构所做的额外工作。在繁重的工作负载（例如多个并发连接）下，自适应哈希索引的访问有时会导致资源争用。使用 `LIKE` 运算符和 `%` 通配符的查询也往往不会受益。对于不能从自适应哈希索引中受益的工作负载，将其关闭可以减少不必要的性能开销。由于很难提前预测自适应哈希索引是否适合特定系统和工作负载，因此请考虑在启用和禁用它的情况下运行基准测试。

The adaptive hash index feature is partitioned. Each index is bound to a specific partition, and each partition is protected by a separate latch. Partitioning is controlled by the [`innodb_adaptive_hash_index_parts`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index_parts) variable. The [`innodb_adaptive_hash_index_parts`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index_parts) variable is set to 8 by default. The maximum setting is 512.

> 自适应哈希索引特征是被分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的锁存器保护。分区由 [`innodb_adaptive_hash_index_parts`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index_parts) 变量控制。

You can monitor adaptive hash index use and contention in the `SEMAPHORES` section of [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html) output. If there are numerous threads waiting on rw-latches created in `btr0sea.c`, consider increasing the number of adaptive hash index partitions or disabling the adaptive hash index.

> 可以在 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html) 输出的 `SEMAPHORES` 部分监控自适应哈希索引的使用和争用状况.如果有大量线程等待在 `btr0sea.c` 中创建的 rw-latch，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引。

For information about the performance characteristics of hash indexes, see [Section 8.3.9, “Comparison of B-Tree and Hash Indexes”](https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html).