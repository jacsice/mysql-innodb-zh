### 15.5.2 Change Buffer

The change buffer is a special data structure that caches changes to [secondary index](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index) pages when those pages are not in the [buffer pool](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool). The buffered changes, which may result from [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html), [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html), or [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html) operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.

> 更改缓冲区是一种特殊的数据结构，用来缓存不在缓存池中的二级索引的修改页。缓冲的更改可能来自 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)、[`UPDATE`](https://dev.mysql .com/doc/refman/8.0/en/update.html)，或 [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html) 操作 (DML)，稍后当页面被其他读取操作加载到缓冲池中时被合并。

<img src="/Users/zhangbo/Desktop/mysql-innodb-zh/images/15.3_change_buffer.png" style="zoom:50%;" />

Unlike [clustered indexes](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index), secondary indexes are usually nonunique, and inserts into secondary indexes happen in a relatively random order. Similarly, deletes and updates may affect secondary index pages that are not adjacently located in an index tree. Merging cached changes at a later time, when affected pages are read into the buffer pool by other operations, avoids substantial random access I/O that would be required to read secondary index pages into the buffer pool from disk.

>与聚集索引不同，二级索引通常是非唯一的，并且插入二级索引的顺序相对随机。类似地，删除和更新可能会影响索引树中不相邻的二级索引页面。当受影响的页面被其他操作读入缓冲池时，稍后合并缓存的更改，避免了将二级索引页面从磁盘读入缓冲池所需的大量随机访问 I/O。

Periodically, the purge operation that runs when the system is mostly idle, or during a slow shutdown, writes the updated index pages to disk. The purge operation can write disk blocks for a series of index values more efficiently than if each value were written to disk immediately.

> 在系统处于大部分空闲时或在缓慢关闭期间，会定期运行清除操作将更新的索引页写入磁盘。与立即将每个值写入磁盘相比，定期清除操作可以更有效地批量将索引值写入磁盘块。

Change buffer merging may take several hours when there are many affected rows and numerous secondary indexes to update. During this time, disk I/O is increased, which can cause a significant slowdown for disk-bound queries. Change buffer merging may also continue to occur after a transaction is committed, and even after a server shutdown and restart (see [Section 15.21.3, “Forcing InnoDB Recovery”](https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html) for more information).

>当有许多受影响的行和许多二级索引要更新时，更改缓冲区合并可能需要几个小时。在此期间，磁盘 I/O 会增加，这可能会导致磁盘查询变慢。在事务提交后，甚至在服务器关闭并重新启动后，更改缓冲区合并也可能继续发生。

In memory, the change buffer occupies part of the buffer pool. On disk, the change buffer is part of the system tablespace, where index changes are buffered when the database server is shut down.

> 在内存中，更改缓冲区占据了缓冲池的一部分。在磁盘上，当数据库服务器关闭时，索引更改被缓冲在磁盘上，更改缓冲区是系统表空间的一部分。

The type of data cached in the change buffer is governed by the [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) variable. For more information, see [Configuring Change Buffering](https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-configuration). You can also configure the maximum change buffer size. For more information, see [Configuring the Change Buffer Maximum Size](https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size).

> 缓存在更改缓冲区中的数据类型由 [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) 变量控制。

Change buffering is not supported for a secondary index if the index contains a descending index column or if the primary key includes a descending index column.

> 如果索引包含降序索引列或主键包含降序索引列，则二级索引不支持更改缓冲。

For answers to frequently asked questions about the change buffer, see [Section A.16, “MySQL 8.0 FAQ: InnoDB Change Buffer”](https://dev.mysql.com/doc/refman/8.0/en/faqs-innodb-change-buffer.html).



#### Configuring Change Buffering

> 配置`更改缓存`

When [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html), [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/update.html), and [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html) operations are performed on a table, the values of indexed columns (particularly the values of secondary keys) are often in an unsorted order, requiring substantial I/O to bring secondary indexes up to date. The [change buffer](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_change_buffer) caches changes to secondary index entries when the relevant [page](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page) is not in the [buffer pool](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool), thus avoiding expensive I/O operations by not immediately reading in the page from disk. The buffered changes are merged when the page is loaded into the buffer pool, and the updated page is later flushed to disk. The `InnoDB` main thread merges buffered changes when the server is nearly idle, and during a [slow shutdown](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_slow_shutdown).

> 当使用 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)，[`UPDATE`](https://dev.mysql.com/doc/refman/ 8.0/en/update.html) 和 [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/delete.html) 对表执行操作时，索引列的值（尤其是辅助键的值）通常是未排序的，需要大量 I/O 才能使二级索引保持最新。当相关[页面](https://dev.mysql) 不在[缓冲池](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool)时， [更改缓冲区](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_change_buffer)缓存二级索引条目，从而通过不立即从磁盘读取页面来避免昂贵的 I/O 操作。当页面加载到缓冲池中时缓冲的更改才被合并，更新的页面稍后被刷新到磁盘。 `InnoDB` 主线程在服务器几乎空闲时合并缓冲的更改，或者在  [slow shutdown](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_slow_shutdown)的时候。

Because it can result in fewer disk reads and writes, change buffering is most valuable for workloads that are I/O-bound; for example, applications with a high volume of DML operations such as bulk inserts benefit from change buffering.

> 因为它可以减少磁盘读取和写入，所以更改缓冲对于 I/O 密集型最有价值；例如，具有大量 DML 操作（如批量插入）的应用程序受益于更改缓冲。

However, the change buffer occupies a part of the buffer pool, reducing the memory available to cache data pages. If the working set almost fits in the buffer pool, or if your tables have relatively few secondary indexes, it may be useful to disable change buffering. If the working data set fits entirely within the buffer pool, change buffering does not impose extra overhead, because it only applies to pages that are not in the buffer pool.

>但是，更改缓冲区占用了缓冲池的一部分，从而减少了可用于缓存数据页的内存。如果工作集几乎适合缓冲池，或者如果您的表具有相对较少的二级索引，则禁用更改缓冲可能很有用。如果工作数据集完全适合缓冲池，则更改缓冲不会带来额外的开销，因为它仅适用于不在缓冲池中的页面。（？）

The [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) variable controls the extent to which `InnoDB` performs change buffering. You can enable or disable buffering for inserts, delete operations (when index records are initially marked for deletion) and purge operations (when index records are physically deleted). An update operation is a combination of an insert and a delete. The default [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) value is `all`.

>[`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) 变量控制 `InnoDB` 执行更改缓冲的程度。可以为插入、删除操作（索引记录最初标记为删除时）和清除操作（索引记录被物理删除时）启用或禁用缓冲。更新操作是插入和删除的组合。默认 [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) 值为 `all`。

Permitted [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) values include:

> 允许的参数值包括：

- **`all`**

  The default value: buffer inserts, delete-marking operations, and purges.

- **`none`**

  Do not buffer any operations.

- **`inserts`**

  Buffer insert operations.

- **`deletes`**

  Buffer delete-marking operations.

- **`changes`**

  Buffer both inserts and delete-marking operations.

- **`purges`**

  Buffer the physical deletion operations that happen in the background.

You can set the [`innodb_change_buffering`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering) variable in the MySQL option file (`my.cnf` or `my.ini`) or change it dynamically with the [`SET GLOBAL`](https://dev.mysql.com/doc/refman/8.0/en/set-variable.html) statement, which requires privileges sufficient to set global system variables. See [Section 5.1.9.1, “System Variable Privileges”](https://dev.mysql.com/doc/refman/8.0/en/system-variable-privileges.html). Changing the setting affects the buffering of new operations; the merging of existing buffered entries is not affected.

> 可以在 MySQL 选项文件（`my.cnf` 或 ` my.ini`) 或使用 [`SET GLOBAL`](https://dev.mysql.com/doc/refman/8.0/en/set-variable.html) 语句动态更改它，这需要足够的权限才能设置全局系统变量。请参阅 [第 5.1.9.1 节，“系统变量权限”](https://dev.mysql.com/doc/refman/8.0/en/system-variable-privileges.html)。更改设置会影响新操作的缓冲；现有缓冲条目的合并不受影响。



#### Configuring the Change Buffer Maximum Size

The [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) variable permits configuring the maximum size of the change buffer as a percentage of the total size of the buffer pool. By default, [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) is set to 25. The maximum setting is 50.

> [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) 变量允许将更改缓冲区的最大值配置为缓冲池的总大小的百分比。默认情况下，[`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) 设置为 25。最大设置为 50。

Consider increasing [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) on a MySQL server with heavy insert, update, and delete activity, where change buffer merging does not keep pace with new change buffer entries, causing the change buffer to reach its maximum size limit.

> 考虑在具有大量插入、更新和删除活动的 MySQL 服务器上增加 [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size)，更改缓冲区合并跟不上新的更改缓冲区条目，导致更改缓冲区达到其最大大小限制。

Consider decreasing [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) on a MySQL server with static data used for reporting, or if the change buffer consumes too much of the memory space shared with the buffer pool, causing pages to age out of the buffer pool sooner than desired.

> 考虑在具有用于报告的静态数据的 MySQL 服务器上减小 [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size)，或者如果更改缓冲区消耗过多与缓冲池共享的内存空间，导致页面比预期更早地从缓冲池中淘汰。

Test different settings with a representative workload to determine an optimal configuration. The [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) variable is dynamic, which permits modifying the setting without restarting the server.

> 使用具有代表性的工作负载测试不同的设置以确定最佳配置。 [`innodb_change_buffer_max_size`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size) 变量是动态的，它允许在不重新启动服务器的情况下修改设置。



#### Monitoring the Change Buffer

The following options are available for change buffer monitoring:

- `InnoDB` Standard Monitor output includes change buffer status information. To view monitor data, issue the `SHOW ENGINE INNODB STATUS` statement.

  ```sql
  mysql> SHOW ENGINE INNODB STATUS\G
  ```

  Change buffer status information is located under the `INSERT BUFFER AND ADAPTIVE HASH INDEX` heading and appears similar to the following:

  >更改缓冲区状态信息位于“INSERT BUFFER AND ADAPTIVE HASH INDEX”标题下，类似于以下内容：

  ```sql
  -------------------------------------
  INSERT BUFFER AND ADAPTIVE HASH INDEX
  -------------------------------------
  Ibuf: size 1, free list len 0, seg size 2, 0 merges
  merged operations:
   insert 0, delete mark 0, delete 0
  discarded operations:
   insert 0, delete mark 0, delete 0
  Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
  13577.57 hash searches/s, 202.47 non-hash searches/s
  ```

  For more information, see [Section 15.17.3, “InnoDB Standard Monitor and Lock Monitor Output”](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html).