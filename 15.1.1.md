### 15.1.1 Benefits of Using InnoDB Tables

`InnoDB` tables have the following benefits:

If the server unexpectedly exits because of a hardware or software issue, regardless of what was happening in the database at the time, you don't need to do anything special after restarting the database. `InnoDB` crash recovery automatically finalizes changes that were committed before the time of the crash, and undoes changes that were in process but not committed, permitting you to restart and continue from where you left off. 

> 如果服务器由于硬件或软件问题而意外退出，无论当时数据库中发生了什么，您都无需在重新启动数据库后执行任何特殊操作。 InnoDB 崩溃恢复自动完成在崩溃之前提交的更改，并撤消正在进行但未提交的更改，允许您重新启动并从上次中断的地方继续。

The `InnoDB` storage engine maintains its own buffer pool that caches table and index data in main memory as data is accessed. Frequently used data is processed directly from memory. This cache applies to many types of information and speeds up processing. On dedicated database servers, up to 80% of physical memory is often assigned to the buffer pool. 

> InnoDB 存储引擎维护自己的缓冲池，在访问数据时将表和索引数据缓存在主内存中。经常使用的数据直接在内存中处理。这个缓存适用于多种类型的信息并能加快处理速度。在专用数据库服务器上，多达 80% 的物理内存通常分配给缓冲池。

If you split up related data into different tables, you can set up foreign keys that enforce referential integrity.

> 如果将相关数据拆分到不同的表中，则可以设置强制参照完整性的外键。

If data becomes corrupted on disk or in memory, a checksum mechanism alerts you to the bogus data before you use it. The [`innodb_checksum_algorithm`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_checksum_algorithm) variable defines the checksum algorithm used by `InnoDB`.

When you design a database with appropriate primary key columns for each table, operations involving those columns are automatically optimized. It is very fast to reference the primary key columns in [`WHERE`](https://dev.mysql.com/doc/refman/8.0/en/select.html) clauses, [`ORDER BY`](https://dev.mysql.com/doc/refman/8.0/en/select.html) clauses, [`GROUP BY`](https://dev.mysql.com/doc/refman/8.0/en/select.html) clauses, and join operations. See [Section 15.6.2.1, “Clustered and Secondary Indexes”](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html).

> 如果磁盘或内存中的数据损坏，校验和 机制会在您使用之前提醒您注意虚假数据。 innodb_checksum_algorithm 变量定义了 InnoDB 使用的 校验和 算法。
>
> 当您为每个表设计具有适当主键列的数据库时，会自动优化涉及这些列的操作。在 WHERE 子句、ORDER BY 子句、GROUP BY 子句和连接操作中引用主键列的速度会非常快。

Inserts, updates, and deletes are optimized by an automatic mechanism called change buffering. `InnoDB` not only allows concurrent read and write access to the same table, it caches changed data to streamline disk I/O.

Performance benefits are not limited to large tables with long-running queries. When the same rows are accessed over and over from a table, the Adaptive Hash Index takes over to make these lookups even faster, as if they came out of a hash table. 

> 插入、更新和删除 通过称为change buffering的自动机制进行优化。 InnoDB 不仅允许对同一个表进行并发读写访问，它还缓存更改的数据以简化磁盘 I/O。
>
> 性能优势不仅限于具有长时间运行查询的大型表。当从表中一遍又一遍地访问相同的行时，自适应哈希索引会使这些查找更快，就像它们来自哈希表一样。

You can compress tables and associated indexes. 

> 您可以压缩表和关联的索引。

You can encrypt your data.

> 您可以加密您的数据。

You can create and drop indexes and perform other DDL operations with much less impact on performance and availability. 

> 您可以创建和删除索引以及执行其他 DDL 操作，对性能和可用性的影响很小

Truncating a file-per-table tablespace is very fast and can free up disk space for the operating system to reuse rather than only `InnoDB`. 

> 截断每个表的文件表空间非常快，可以释放磁盘空间供操作系统重用，而不仅仅是让 InnoDB占用

The storage layout for table data is more efficient for [`BLOB`](https://dev.mysql.com/doc/refman/8.0/en/blob.html) and long text fields, with the `DYNAMIC` row format. 

> 表数据的存储布局对于使用 DYNAMIC 行格式的 BLOB 和长文本字段更有效

You can monitor the internal workings of the storage engine by querying `INFORMATION_SCHEMA` tables.

> 您可以通过查询 INFORMATION_SCHEMA 表来监控存储引擎的内部工作

You can monitor the performance details of the storage engine by querying Performance Schema tables. 

> 您可以通过查询 Performance Schema 表来监控存储引擎的性能详细信息

You can mix `InnoDB` tables with tables from other MySQL storage engines, even within the same statement. For example, you can use a join operation to combine data from `InnoDB` and [`MEMORY`](https://dev.mysql.com/doc/refman/8.0/en/memory-storage-engine.html) tables in a single query.

> 您可以将 InnoDB 表与其他 MySQL 存储引擎的表混合使用，即使在同一语句中也是如此。例如，您可以在单个查询中使用join操作来处理来自 InnoDB 和 MEMORY 表的数据。

`InnoDB` has been designed for CPU efficiency and maximum performance when processing large data volumes.

> InnoDB 是专为处理大量数据时的 CPU 效率和最大性能而设计。（不太通顺）

`InnoDB` tables can handle large quantities of data, even on operating systems where file size is limited to 2GB.

> InnoDB 表可以处理大量数据，即使在文件大小限制为 2GB 的操作系统上也是如此。

