## 15.3 InnoDB Multi-Versioning

`InnoDB` is a multi-version storage engine. It keeps information about old versions of changed rows to support transactional features such as concurrency and rollback. This information is stored in undo tablespaces in a data structure called a rollback segment. See [Section 15.6.3.4, “Undo Tablespaces”](https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html). `InnoDB` uses the information in the rollback segment to perform the undo operations needed in a transaction rollback. It also uses the information to build earlier versions of a row for a consistent read. See [Section 15.7.2.3, “Consistent Nonlocking Reads”](https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html).

> ```
> InnoDB 是一个多版本的存储引擎。它保留已更改行的旧版本的信息以支持事务功能，例如并发和回滚。这些信息保存在undo表空间中，一种叫做回滚段的数据结构。请参阅第 15.6.3.4 节，“undo tablespaces”。 InnoDB 使用回滚段中的信息来执行事务回滚所需的撤消操作。它还使用这些信息来构建行的早期版本以实现一致的读取。请参见第 15.7.2.3 节，“Consistent Nonlocking Reads”。
> ```

Internally, `InnoDB` adds three fields to each row stored in the database:

> 在内部，InnoDB 为存储在数据库中的每一行添加三个字段：

- A 6-byte `DB_TRX_ID` field indicates the transaction identifier for the last transaction that inserted or updated the row. Also, a deletion is treated internally as an update where a special bit in the row is set to mark it as deleted.

> 一个 6 字节的 DB_TRX_ID 字段用来标识插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，设置行中的特殊位以将其标记为已删除。

- A 7-byte `DB_ROLL_PTR` field called the roll pointer. The roll pointer points to an undo log record written to the rollback segment. If the row was updated, the undo log record contains the information necessary to rebuild the content of the row before it was updated.

> 一个 7 字节的 DB_ROLL_PTR 字段称为滚动指针。滚动指针指向写入回滚段的undo log记录 。如果该行数据有更新操作，并且undo log中包含这一行信息，在该行内容被更新前，很有必要重建这一行的内容。

- A 6-byte `DB_ROW_ID` field contains a row ID that increases monotonically as new rows are inserted. If `InnoDB` generates a clustered index automatically, the index contains row ID values. Otherwise, the `DB_ROW_ID` column does not appear in any index.

> 一个 6 字节的 DB_ROW_ID 字段包含一个行 ID，随着插入新行而递增。如果 InnoDB 自动生成聚集索引，则索引包含行 ID 值。否则，DB_ROW_ID 列不会出现在任何普通索引中。

Undo logs in the rollback segment are divided into insert and update undo logs. Insert undo logs are needed only in transaction rollback and can be discarded as soon as the transaction commits. Update undo logs are used also in consistent reads, but they can be discarded only after there is no transaction present for which `InnoDB` has assigned a snapshot that in a consistent read could require the information in the update undo log to build an earlier version of a database row. For additional information about undo logs, see [Section 15.6.6, “Undo Logs”](https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html).

> 回滚段中的undo logs分为insert和update undo logs。仅在事务回滚时才需要insert undo logs，并且可以在事务提交后立即丢弃。update undo logs用于一致性读取，但只有在不存在“InnoDB”为其分配快照的事务后才能丢弃它们，在一致性读取中可能需要update undo logs中的信息来构建数据库行的版本记录。

It is recommend that you commit transactions regularly, including transactions that issue only consistent reads. Otherwise, `InnoDB` cannot discard data from the update undo logs, and the rollback segment may grow too big, filling up the undo tablespace in which it resides. For information about managing undo tablespaces, see [Section 15.6.3.4, “Undo Tablespaces”](https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html).

> 建议定期提交事务，包括仅一致读取的事务。否则，`InnoDB` 无法丢弃更新 undo 日志中的数据，回滚段可能会变得太大，填满它所在的 undo 表空间。

The physical size of an undo log record in the rollback segment is typically smaller than the corresponding inserted or updated row. You can use this information to calculate the space needed for your rollback segment.

> 回滚段中撤消日志记录的物理大小通常小于相应的插入或更新行。您可以使用此信息来计算回滚段所需的空间。

In the `InnoDB` multi-versioning scheme, a row is not physically removed from the database immediately when you delete it with an SQL statement. `InnoDB` only physically removes the corresponding row and its index records when it discards the update undo log record written for the deletion. This removal operation is called a purge, and it is quite fast, usually taking the same order of time as the SQL statement that did the deletion.

> 在 `InnoDB` 多版本方案中，当使用 SQL 语句删除行时，不会立即从数据库中物理删除它。 `InnoDB` 仅在丢弃为删除而写入的更新撤消日志记录时，才会物理删除相应的行及其索引记录。这种删除操作称为清除，它非常快，通常与执行删除的 SQL 语句所用的时间顺序相同。

If you insert and delete rows in smallish batches at about the same rate in the table, the purge thread can start to lag behind and the table can grow bigger and bigger because of all the “dead” rows, making everything disk-bound and very slow. In such cases, throttle new row operations, and allocate more resources to the purge thread by tuning the [`innodb_max_purge_lag`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_max_purge_lag) system variable. For more information, see [Section 15.8.9, “Purge Configuration”](https://dev.mysql.com/doc/refman/8.0/en/innodb-purge-configuration.html).

> 如果在表中以大致相同的速率以小批量插入和删除行，则清除线程可能会开始滞后，并且由于所有“删除”行，表会变得越来越大，从而使所有内容都受磁盘限制变的非常慢。在这种情况下，通过调整 [`innodb_max_purge_lag`](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html# sysvar_innodb_max_purge_lag) 系统变量，限制新行操作，并为清除线程分配更多资源。

### Multi-Versioning and Secondary Indexes

> 多版本和二级索引

`InnoDB` multiversion concurrency control (MVCC) treats secondary indexes differently than clustered indexes. Records in a clustered index are updated in-place, and their hidden system columns point undo log entries from which earlier versions of records can be reconstructed. Unlike clustered index records, secondary index records do not contain hidden system columns nor are they updated in-place.

> `InnoDB` 多版本并发控制 (MVCC) 对二级索引的处理与聚集索引不同。聚集索引中的记录在原地更新，它们的隐藏系统列指向撤消日志条目，可以从中重建早期版本的记录。与聚集索引记录不同，二级索引记录不包含隐藏的系统列，也不会就地更新。

When a secondary index column is updated, old secondary index records are delete-marked, new records are inserted, and delete-marked records are eventually purged. When a secondary index record is delete-marked or the secondary index page is updated by a newer transaction, `InnoDB` looks up the database record in the clustered index. In the clustered index, the record's `DB_TRX_ID` is checked, and the correct version of the record is retrieved from the undo log if the record was modified after the reading transaction was initiated.

> 当二级索引列被更新时，旧二级索引记录被标记为删除，新记录被插入，并且被删除标记的记录最终被清除。当二级索引记录被标记为删除或二级索引页面被更新的事务更新时，`InnoDB` 在聚集索引中查找数据库记录。在聚集索引中，检查记录的`DB_TRX_ID`，如果在启动读取事务后修改了记录，则从撤消日志中检索记录的正确版本。

If a secondary index record is marked for deletion or the secondary index page is updated by a newer transaction, the [covering index](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index) technique is not used. Instead of returning values from the index structure, `InnoDB` looks up the record in the clustered index.

> 如果二级索引记录被标记为删除或二级索引页面被较新的事务更新，[覆盖索引](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index ) 技术未使用。 `InnoDB` 不是从索引结构返回值，而是在聚集索引中查找记录。

However, if the [index condition pushdown (ICP)](https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html) optimization is enabled, and parts of the `WHERE` condition can be evaluated using only fields from the index, the MySQL server still pushes this part of the `WHERE` condition down to the storage engine where it is evaluated using the index. If no matching records are found, the clustered index lookup is avoided. If matching records are found, even among delete-marked records, `InnoDB` looks up the record in the clustered index.

> 但是，如果启用了 [index condition pushdown (ICP)](https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html) 优化，并且部分 ` WHERE` 条件只能使用索引中的字段进行评估，MySQL 服务器仍将这部分“WHERE”条件 下推到使用索引评估的存储引擎。如果没有找到匹配的记录，则避免聚集索引查找。如果找到匹配的记录，即使在删除标记的记录中，InnoDB 也会在聚集索引中查找记录。